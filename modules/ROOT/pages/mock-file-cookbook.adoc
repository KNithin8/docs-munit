= Mocking Resources for Your Tests
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

When the tests suites start to grow in size and complexity, itâ€™s a good practice to externalize some parts of the code to test resources so that you can keep the code clean and organized as well as reuse the files that you need to mock for your tests without the need to have duplicated code.

In Mule 3, you used to use a `getResourceAsString()` function to incorporate external or mocked resources to your tests. In Mule 4, you can leverage DataWeave to mock your code for your tests.

== Mocking Files Using DataWeave Scripts

You can use a DataWeave script that returns the data that you want to mock, save the file under a folder in `src\test\resources` and then use a DataWeave function to read this file.

For example, define a `mockPost.dwl` file in the `src/test/resources/sample_data` folder with the following content:

[source]
----
%dw 2.0
output application/json
---
{
	"foo" : "var"
}
----

This DataWeave file is a sample that creates a mock payload that you want to return in an `http:request`. When configuring the `then-return` section in the `mock-when`, use the `readUrl` function to read the mapping file:

[source,xml,linenums]
----
<munit-tools:then-return>
  <munit-tools:payload value="#[readUrl('classpath://sample_data/mockPost.dwl')]" mediaType="application/json" encoding="UTF-8" />
</munit-tools:then-return>
----

The `classpath-based` URL uses the `classpath:` protocol prefix to find the file we defined under `src/test/resources`.

== Mocking Files Using Variables in a DataWeave Module

You can create a DataWeave module to centralize all your mocks in a single file by declaring them in DataWeave variables.

For example, to create a custom DataWeave module, create a `TestData.dwl` file under `src\test\resources` and add a couple of variables with references to different mocks either from files or inline:

[source]
----
import getResourceAsString from MunitTools

var mockPost = readUrl('classpath://sample_data/mockPost.dwl')
var foo = "N123"
var jsonFromFile = read(getResourceAsString('sample_data/mydata.json'), 'application/json')
var jsonObject = { paymentID: "1B56925769601335TLQMIWVY" }
----

You can then access any of the defined variables in the DataWeave module by importing the variables from your custom module:

[source,xml,linenums]
----
<munit-tools:then-return >
				<munit-tools:variables>
        				<munit-tools:variable key="ticket" value="#[import TestData output application/json --- TestData::mockPost]" mediaType="application/json" />
				</munit-tools:variables>
</munit-tools:then-return>
----

Using this approach with a proper file naming convention and folder structure should help you have cleaner code and organized mocks for your MUnit test suites as well as provide you an easy way to reuse code.

== See Also

* xref:mule-runtime::dataweave-create-module.adoc[Create Custom Modules and Mappings]
